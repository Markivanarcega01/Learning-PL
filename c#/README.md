# Days 1–60: C# Fundamentals

Day 1: Install .NET SDK and Visual Studio or VS Code with C# Extension
Day 2: Create a console app that prints “Hello, World!”
Day 3: Print your name and age using variables
Day 4: Take user input and display it back
Day 5: Create a calculator that adds two numbers
Day 6: Create variables of types int, double, char, bool, string
Day 7: Write a program that performs all arithmetic operations
Day 8: Create a program to swap two variables using a third variable
Day 9: Write a program using single-line and multi-line comments
Day 10: Create a program to find the square of a number

# Conditionals
Day 11: Write a program to check if a number is positive or negative
Day 12: Check if a number is even or odd
Day 13: Find the largest of three numbers
Day 14: Create a basic grade evaluator using if-else
Day 15: Use a switch statement to print days of the week
Day 16: Compare two strings for equality
Day 17: Write a login simulation (username/password check)
Day 18: Use a ternary operator to assign a result
Day 19: Validate age input for driving eligibility
Day 20: Create a simple tip calculator using if-else

# Loops
Day 21: Print numbers 1 to 10 using a for loop
Day 22: Print even numbers from 1 to 20 using a while loop
Day 23: Sum of first 10 natural numbers
Day 24: Print multiplication table of a given number
Day 25: Print Fibonacci series up to 10 terms
Day 26: Use break to stop a loop at a given number
Day 27: Use continue to skip even numbers in a loop
Day 28: Reverse a string using a loop
Day 29: Count vowels in a string
Day 30: Display a triangle pattern using *

# Arrays & Methods
Day 31: Declare an integer array and print its elements
Day 32: Find the largest element in an array
Day 33: Reverse an array manually
Day 34: Sort an array without built-in methods
Day 35: Create a method to return the sum of two numbers
Day 36: Create a method that returns the factorial of a number
Day 37: Create an overloaded method for printing integers and strings
Day 38: Create a method that accepts an array and returns its average
Day 39: Use ref and out parameters in a method
Day 40: Create a method to check for palindromes

# Strings
Day 41: Count the number of words in a sentence
Day 42: Convert a sentence to uppercase and lowercase
Day 43: Remove white spaces from a string
Day 44: Reverse a string without using built-in methods
Day 45: Compare two strings alphabetically
Day 46: Replace a word in a sentence
Day 47: Extract substring from a given string
Day 48: Join an array of words into a single string
Day 49: Count frequency of a character in a string
Day 50: Check if a string is an anagram of another

# Classes & Objects
Day 51: Create a class Car with fields make, model, year
Day 52: Create a constructor that initializes an object
Day 53: Create properties for a class and use get/set
Day 54: Add a method Start() to the Car class and call it
Day 55: Create multiple objects from a class and display them
Day 56: Create a static method and call it without an object
Day 57: Demonstrate use of readonly and const
Day 58: Create a class with a List<string> field and add items
Day 59: Write a class with a method to display object details
Day 60: Create a basic class diagram and implement it in code

# Days 61–120: Intermediate Level – OOP, File I/O, LINQ, JSON

# Object-Oriented Programming (OOP)
Day 61: Create a Person class and inherit it in a Student class
Day 62: Add a method in the Student class that overrides a method in Person
Day 63: Create an abstract class Animal with an abstract method MakeSound()
Day 64: Implement MakeSound() in Dog and Cat subclasses
Day 65: Create an interface IDriveable with method Drive()
Day 66: Implement the interface in a Car and Bike class
Day 67: Use polymorphism to call Drive() from a base reference
Day 68: Use base keyword to call parent class constructor
Day 69: Practice object upcasting and downcasting
Day 70: Create a class that uses encapsulation with private fields and public properties

Day 71: Create a Shape class and override Area() method in Circle and Rectangle
Day 72: Use a List<Shape> and loop through each calling the polymorphic Area() method
Day 73: Create a static helper class MathHelper with reusable methods
Day 74: Create a class with overloaded constructors
Day 75: Demonstrate method chaining by returning this in methods
Day 76: Create a basic UML diagram and implement its classes
Day 77: Add XML documentation comments to class and methods
Day 78: Create a ToString() override in your class
Day 79: Use object initializers to populate objects
Day 80: Create an object comparer using IComparable interface

# Collections & Generics
Day 81: Create a List<string> and perform add, remove, search operations
Day 82: Use Dictionary<int, string> to store student IDs and names
Day 83: Loop through a Dictionary using foreach
Day 84: Convert an array to a list and sort it
Day 85: Use Queue<string> to simulate a line of customers
Day 86: Use Stack<int> to reverse numbers
Day 87: Create a generic method to swap two values
Day 88: Create a custom generic class Box<T>
Day 89: Filter a list using FindAll()
Day 90: Remove duplicates from a list using Distinct()

# File Handling
Day 91: Write text to a file using File.WriteAllText()
Day 92: Read text from a file using File.ReadAllText()
Day 93: Append a line to a file
Day 94: Read file line-by-line and count total lines
Day 95: Count the number of words in a text file
Day 96: Delete a file if it exists
Day 97: Copy and move a file to a different directory
Day 98: Use Directory class to list all files in a folder
Day 99: Create a text file logger class
Day 100: Use using statement for file reading with StreamReader

# Exception Handling
Day 101: Write a program that catches divide-by-zero exception
Day 102: Handle FormatException while parsing input
Day 103: Use finally block to clean up resources
Day 104: Create a method that throws a custom exception
Day 105: Catch multiple exceptions in a single try block
Day 106: Log exception messages to a file
Day 107: Create a reusable error handler method
Day 108: Use when keyword to filter exceptions
Day 109: Create a class that validates input and throws if invalid
Day 110: Chain multiple custom exceptions

# LINQ Basics
Day 111: Create a list of integers and use LINQ to select even numbers
Day 112: Use Select() to project names from a list of objects
Day 113: Sort a list of strings using OrderBy()
Day 114: Use GroupBy() to group employees by department
Day 115: Filter students with scores above 80 using Where()
Day 116: Get the first and last item from a list using First() and Last()
Day 117: Use Any() and All() to test conditions
Day 118: Use Sum(), Average(), Min(), Max()
Day 119: Convert a list to a dictionary using ToDictionary()
Day 120: Join two lists using LINQ join

# Days 121–180: Advanced LINQ, JSON, Async, Multithreading

# Advanced LINQ
Day 121: Chain multiple LINQ methods in a single query
Day 122: Use SelectMany() to flatten nested collections
Day 123: Use DistinctBy() to get unique values based on a property
Day 124: Create a complex query with group, orderby, and select
Day 125: Use LINQ to filter and paginate (e.g., .Skip(5).Take(5))
Day 126: Query data using LINQ query syntax (from, select)
Day 127: Use Aggregate() to perform custom aggregation
Day 128: Count items matching a condition with Count()
Day 129: Create a LINQ expression that returns top 3 scores
Day 130: Convert a LINQ result to a dictionary

# JSON Serialization / Deserialization
Day 131: Install System.Text.Json or use it via .NET
Day 132: Create a C# object and serialize it to JSON
Day 133: Deserialize JSON to a C# object
Day 134: Read JSON from a file and display data
Day 135: Write a C# list to a JSON file
Day 136: Handle missing properties during deserialization
Day 137: Format JSON output with indented option
Day 138: Ignore null values in JSON using options
Day 139: Create a model with nested objects and serialize it
Day 140: Deserialize a JSON array into a list of objects

# Async Programming (Asynchronous Tasks)
Day 141: Create an async method using async and await
Day 142: Use Task.Delay() to simulate long-running operation
Day 143: Call two async methods sequentially
Day 144: Call async methods in parallel using Task.WhenAll()
Day 145: Handle exceptions in async methods
Day 146: Create an async file read operation
Day 147: Use ConfigureAwait(false) in a library method
Day 148: Compare sync vs. async file reading performance
Day 149: Create a method that returns Task<int>
Day 150: Create a reusable HttpClient call that fetches data asynchronously

# Multithreading & Tasks
Day 151: Create a thread using Thread class
Day 152: Create a method and run it on a new thread
Day 153: Use Thread.Sleep() to simulate work
Day 154: Use Thread.Join() to wait for thread to complete
Day 155: Use ThreadPool to run background work
Day 156: Run background task using Task.Run()
Day 157: Pass parameters to a new thread
Day 158: Synchronize access to a shared variable using lock
Day 159: Use Monitor.Enter and Monitor.Exit for locking
Day 160: Demonstrate race condition with shared resource

Day 161: Use Mutex for process-level locking
Day 162: Use Semaphore to limit concurrent access
Day 163: Demonstrate deadlock with two locks (and avoid it)
Day 164: Cancel a task using CancellationToken
Day 165: Pause/resume a thread manually
Day 166: Implement a producer-consumer pattern using threads
Day 167: Use ConcurrentQueue<T> in a multithreaded scenario
Day 168: Use BlockingCollection<T> for thread-safe data
Day 169: Use Parallel.For for parallel processing
Day 170: Profile and measure execution time of parallel vs. single-threaded

# Task Coordination and Best Practices
Day 171: Chain multiple tasks using ContinueWith()
Day 172: Create a task timeout using Task.Wait()
Day 173: Return value from a background task
Day 174: Share data between tasks safely
Day 175: Handle exceptions in a Task.WhenAll() setup
Day 176: Use ValueTask in performance-sensitive code
Day 177: Use AsyncLocal<T> to pass context between async calls
Day 178: Create a progress reporter using IProgress<T>
Day 179: Implement retry logic with exponential backoff using Task.Delay()
Day 180: Create a utility that runs periodic background tasks (e.g., using a timer or loop + delay)

# Days 181–240: Web APIs, Dependency Injection, ASP.NET Core Essentials

# ASP.NET Core Basics
Day 181: Install the ASP.NET Core SDK and create a new web API project
Day 182: Explore the project structure (Program.cs, Startup.cs, Controllers folder)
Day 183: Create your first API controller and return "Hello from API"
Day 184: Add an HTTP GET endpoint that returns a list of strings
Day 185: Add a simple POST endpoint to receive a name and return a greeting
Day 186: Add route parameters to an endpoint (/user/{id})
Day 187: Use [FromQuery] to receive query string values
Day 188: Use [FromBody] to receive JSON data in a POST request
Day 189: Use Swagger to test your endpoints
Day 190: Add status codes (200, 400, 404) to your API responses

# CRUD with In-Memory Data
Day 191: Create a User model with ID, Name, Email
Day 192: Create a service to store users in a List<User>
Day 193: Implement GET /users to return all users
Day 194: Implement GET /users/{id} to return a user by ID
Day 195: Implement POST /users to add a new user
Day 196: Implement PUT /users/{id} to update a user
Day 197: Implement DELETE /users/{id} to remove a user
Day 198: Add error handling for not found users
Day 199: Return CreatedAtAction from POST endpoint
Day 200: Add model validation using [Required], [EmailAddress]

# Dependency Injection
Day 201: Create an interface IUserService and implement it
Day 202: Register the service in the DI container (builder.Services.AddSingleton)
Day 203: Inject the service into your controller using constructor injection
Day 204: Change service from Singleton to Scoped, observe the behavior
Day 205: Inject ILogger<T> and log actions (create, update, delete)
Day 206: Inject a configuration value from appsettings.json
Day 207: Create a TimeService that returns current time and inject it
Day 208: Register multiple services and inject based on scenario
Day 209: Use TryAddScoped to prevent multiple registrations
Day 210: Add a transient service and explore instancing

# Middleware & Request Pipeline
Day 211: Add custom middleware to log every request
Day 212: Log request headers in custom middleware
Day 213: Add global error-handling middleware
Day 214: Add middleware to restrict requests by IP
Day 215: Inject services into middleware using RequestServices.GetService<T>()
Day 216: Add response time to headers using middleware
Day 217: Add a middleware that redirects specific paths
Day 218: Use UseWhen to apply middleware conditionally
Day 219: Use app.UseStaticFiles() to serve static content
Day 220: Create a simple HTML file and serve it from wwwroot

# Security & Authentication Basics
Day 221: Secure an endpoint using [Authorize]
Day 222: Add and configure authentication in Program.cs
Day 223: Create a login endpoint that returns a dummy token
Day 224: Add JWT authentication to the project
Day 225: Protect a route using JWT token-based authorization
Day 226: Validate JWT tokens using middleware
Day 227: Add claims to the JWT token and read them
Day 228: Use role-based authorization [Authorize(Roles="Admin")]
Day 229: Create a login/register system with in-memory users
Day 230: Refresh token on login and manage expiration

# Advanced API Practices
Day 231: Add API versioning to your project
Day 232: Add CORS support to allow requests from a different origin
Day 233: Add Rate Limiting using a simple in-memory tracker
Day 234: Return pagination metadata in response headers
Day 235: Implement file upload in a POST endpoint
Day 236: Return a file in a response (e.g., download PDF)
Day 237: Create a health check endpoint (/health)
Day 238: Create a generic repository interface for reuse
Day 239: Use DTOs to shape API responses
Day 240: Map between model and DTO using AutoMapper

# Days 241–300: EF Core, Databases, Testing, Logging, REST Best Practices

# Entity Framework Core (EF Core) Basics
Day 241: Install EF Core and SQLite packages via NuGet
Day 242: Create a DbContext and connect it to a SQLite database
Day 243: Define a User entity and add it to the DbContext
Day 244: Run your first migration and update the database
Day 245: Use DbContext to add a user record
Day 246: Query users using ToList() and Where()
Day 247: Update a user’s name and save changes
Day 248: Delete a user by ID
Day 249: Use FirstOrDefault and Find() for safe querying
Day 250: Add CreatedAt and UpdatedAt timestamps with automatic values

# EF Core Intermediate (Relationships & Seeding)
Day 251: Create a Post entity with a one-to-many relationship to User
Day 252: Insert a User with multiple Post records
Day 253: Query posts including related user using .Include()
Day 254: Create a many-to-many relationship (e.g., User ⇄ Group)
Day 255: Query many-to-many data using .Include().ThenInclude()
Day 256: Seed initial data via OnModelCreating()
Day 257: Use migrations to update the schema with new fields
Day 258: Add a nullable column and test migration
Day 259: Create indexes using Fluent API
Day 260: Add uniqueness constraint on email column

# API Testing with Postman & Unit Tests
Day 261: Install and set up Postman
Day 262: Test GET and POST endpoints with Postman
Day 263: Send a request with JSON body and test the response
Day 264: Test endpoints with query and route parameters
Day 265: Add custom headers and test their behavior
Day 266: Create and run your first xUnit test project
Day 267: Write a unit test for a service method
Day 268: Mock a repository using Moq
Day 269: Assert multiple conditions using Assert.Multiple
Day 270: Test exception handling with [Fact(ExpectedException)] or try/catch

# Logging and Monitoring
Day 271: Log info and warning messages using ILogger<T>
Day 272: Add logging in controller actions
Day 273: Add try-catch blocks and log errors
Day 274: Log exception stack traces
Day 275: Configure logging levels in appsettings.json
Day 276: Create a custom logger middleware
Day 277: Log request and response bodies
Day 278: Integrate a logging provider like Serilog
Day 279: Use rolling file logging with Serilog
Day 280: Filter logs to specific categories (e.g., MyApp.Controllers)

# REST API Best Practices
Day 281: Rename routes to follow REST conventions (/api/users)
Day 282: Return 201 Created with location header after POST
Day 283: Return 204 No Content for successful DELETE
Day 284: Add consistent error messages in a standard format
Day 285: Use HTTP status codes consistently across endpoints
Day 286: Group routes by controller responsibility (UsersController, PostsController)
Day 287: Document endpoints using Swagger annotations
Day 288: Add global exception handling with custom error model
Day 289: Use ApiController attributes for model binding and validation
Day 290: Create pagination metadata (page, total count, etc.) in GET results

# DTOs, Mapping, and Clean Architecture
Day 291: Create DTOs for input and output models
Day 292: Hide sensitive data (e.g., password) using DTOs
Day 293: Use AutoMapper to map entity to DTO
Day 294: Create mapping profiles with AutoMapper
Day 295: Add validation rules using FluentValidation
Day 296: Structure project into layers: API, Services, Repositories
Day 297: Move business logic to services layer
Day 298: Inject repositories into services via interfaces
Day 299: Refactor controller to call service instead of DbContext
Day 300: Review architecture and identify areas for refactoring

# Days 301–365: Advanced C#, Design Patterns, Performance, Clean Code & Deployment

# Advanced C# Concepts
Day 301: Create and use Span<T> for efficient memory access
Day 302: Use ref and out parameters and know when to use them
Day 303: Understand value vs. reference types with structs and classes
Day 304: Use readonly struct for performance-sensitive data
Day 305: Use pattern matching in switch expressions
Day 306: Use is pattern matching for type checking
Day 307: Create extension methods for existing types
Day 308: Use nameof() for safe code references
Day 309: Explore record vs. class for immutable types
Day 310: Use deconstruction syntax for tuples and records

# Popular Design Patterns (with Code)
Day 311: Implement the Singleton pattern
Day 312: Implement the Factory pattern
Day 313: Use the Strategy pattern for interchangeable algorithms
Day 314: Implement the Observer pattern (e.g., event notifications)
Day 315: Use the Repository pattern for data access abstraction
Day 316: Implement the Unit of Work pattern
Day 317: Implement the Dependency Injection pattern manually
Day 318: Use the Builder pattern to create complex objects
Day 319: Implement the Adapter pattern to bridge incompatible interfaces
Day 320: Combine Strategy and Factory for dynamic service resolution

# Performance Optimization
Day 321: Use Stopwatch to measure method performance
Day 322: Benchmark with BenchmarkDotNet
Day 323: Use StringBuilder instead of string concatenation
Day 324: Optimize LINQ with ToList() at the end of chains
Day 325: Avoid boxing by using generics properly
Day 326: Use async/await to avoid blocking threads
Day 327: Enable response compression in your ASP.NET API
Day 328: Profile CPU and memory usage using Visual Studio tools
Day 329: Cache expensive computations using MemoryCache
Day 330: Use compiled queries in EF Core for performance gains

# Clean Code & Refactoring
Day 331: Identify and extract duplicate code into methods
Day 332: Rename variables for clarity using consistent naming
Day 333: Use early return to reduce nested logic
Day 334: Replace magic numbers with constants or enums
Day 335: Limit method size to no more than 10–20 lines
Day 336: Apply SRP (Single Responsibility Principle) to a class
Day 337: Refactor large switch cases using polymorphism
Day 338: Remove dead or unused code safely
Day 339: Apply DRY (Don't Repeat Yourself) principle
Day 340: Group code files into meaningful folders/namespaces

# Deployment & Production Readiness
Day 341: Publish your ASP.NET Core app using dotnet publish
Day 342: Deploy your app locally and run as a self-hosted server
Day 343: Add environment-based configuration in appsettings.{env}.json
Day 344: Set environment variables and read them in your app
Day 345: Use launch profiles for dev/staging/production
Day 346: Create a Dockerfile for your ASP.NET Core API
Day 347: Build and run the Docker container locally
Day 348: Push your image to Docker Hub
Day 349: Deploy the container to a cloud service (e.g., Azure App Service)
Day 350: Set up GitHub Actions to deploy on code push

# Wrap-Up Challenges & Projects
Day 351: Build a mini blog API with users, posts, and comments
Day 352: Add login and JWT-based authentication to the blog API
Day 353: Add EF Core and store posts in SQLite or SQL Server
Day 354: Implement pagination and filtering on /posts
Day 355: Add a tag system (many-to-many relationship)
Day 356: Add DTOs, mapping, and clean architecture layers
Day 357: Add Swagger and document all endpoints
Day 358: Write unit tests for all services
Day 359: Log all major operations and errors
Day 360: Containerize and deploy the blog API to the cloud

# Final Days: Reflection & Review
Day 361: Review and journal what you've learned in C#
Day 362: Refactor an old piece of your code using clean code principles
Day 363: Explore .NET source code (https://source.dot.net)
Day 364: Write a blog post or LinkedIn article about your C# journey
Day 365: Start your next project or contribute to an open-source .NET repo!